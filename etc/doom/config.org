#+title: Doom Emacs Configuration
#+author: Ryan King
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args :tangle no :results silent :eval no-export
#+startup: fold
* Introduction
Once I realized that the text editor was something that you could customize in my Boston University dorm room, sometime in the fall of 2015, I would go on to spend a great deal of time just sort of screwing around with different editors. This configuration is what powers my current Editor, Emacs with the Doom framework.

** Editor Journey
My editor journey is something that is probably interesting to nobody except for myself, but I felt like writing it up for fun reminiscing more than anything so here it is.

*** Proto-Editors
When I first started programming, I didn't immediately choose a side in the Vim v. Emacs holy war, I was just told what to use. Depending on the situation I wrote code in Game Maker, CodeBlocks, NotePad++, DevC, and probably some others that I've since forgotten. I used a bunch on the Mac also: Coda, Text Wrangler, and one more, that I ended up using for a little bit longer than the rest...

*** Sublime Text 2
I think I even paid the $50 for the license at one point. I think the first thing I really started using the editor for was Lua code for my Corona SDK apps. I have the code somewhere I think. I didn't use too much actual editor functionality. I mean, I used DropBox for version control so I don't think I would have cared too much about a git plugin. I eventually would go onto start using more of Sublime Text 2. I think I did briefly experiment with Coda for a bit for web development, and used IntelliJ for some Java work, but Sublime Text 2 was ultimately the one I would dive into. I didn't do a whole lot, but I installed packages, and split windows. There was a single "a-ha!" moment that I remember where I first ran a Python file in a split window, I think this is when something clicked I would go on to get a hunger for optimizing editors.

*** Emacs
I did a little stint with Emacs. I think I choose it because it was on the school servers we used to run homework. I have no idea how people who didn't just figure out how to run the homework locally actually did homework in nano or terminal vanilla Emacs over SSH. I didn't do much with it besides read a book called "Mastering Emacs." I might have made minor config edits and installed a package or two.

*** Vim
Vim was the first editor I properly dug into. And by dug into, I mean copied and pasted a config off of GitHub. I probably had some mild plugin and config action, but nothing insane. I think I also might have dabbled in some ZSH config by now. This is when I truly fell in love with modal keybindings. I used the product that I will shill from the rooftops: [[https://vim-adventures.com/][Vim Adventures]].

*** Emacs (again)
At some point, I discovered the first [[https://github.com/aaronbieber/dotfiles][set of dotfiles]] that would send me on a lifelong journey of full system customization. I created my own repo, found =r/UnixPorn=, and started slowly working on my full system configuration, which included Emacs as my editor. What was special about the dotfiles I found, was they were by the author of a presentation called "Evil Mode: Or, How I Learned to Stop Worrying and Love Emacs." Which basically said "hey, you can use modal editing in Emacs." A philosophy I would stray from, but return to. I soon found the Spacemacs configuration, which would power me for almost two years. Spacemacs really was the right tool for the job at the time. I didn't need any fancy tool integrations for school projects, and editing LaTeX was really easy, which I did a significant amount of.

*** Vim (just for a hot second)
When I was gearing up to graduate and move to my first real job a Software Engineer, I decided to do a stint in Vim. Might have been NeoVim, but I think I opted for the newly released Vim 8 since NeoVim didn't offer that much different at that point. I think I did write (steal) a config, but I only used it for three projects my last semester when I only had one class.

*** Visual Studio Code
When I started working, Visual Studio Code was really all the rage. It had taken most of the Atom users, and due to peer pressure, I would also boot up Visual Studio Code. I really liked the file switching dialogue, as someone who hadn't discovered ctrl-p and used vinegar for years. I didn't like the window management. Something that Emacs and Vim have that other editors don't is the concept of a buffer. I think Emac's is a better abstraction since Emacs does everything on buffers, but as far as visual sections on the screen that contain files or widgets, they're pretty similar. What this meant was in Vim/Emacs, code files, the file tree, the terminal, etc. all played by the same rules of interaction. In VS Code, code files, the file tree, and the terminal, and other UI widgets all had their own "rules" so learning each set was a lot of work. I eventually made a config that was pretty decent using a plugin to limit tabs per window to one to make buffer behave more like Vim. I think I used it for half a year or so before getting too frustrated and going to Neovim.

*** Neovim
After getting frustrated with Visual Studio Code, which felt like it was getting slower and buggier as time went on, I moved onto Neovim, which I would configure to be slow and buggy. I wrote (stole) a giant multi-file config in VimScript. I got pretty deep this time, started learning about the ecosystem, async plugins, LSP, etc.. There were still some pain points. Project management was a big one that never really felt nice in Vim. So it was only a matter of time until I switched.

*** GoLand
I have to say, GoLand is actually pretty good. If I just wanted an off-the-shelf editor to boot up, spend an hour installing plugins and going through the config then edit code, GoLand would be the one I'd use. Its a bit snappier than the electron editors, has a lot of nice features, has a pretty good Vim plugin, and has decent support for working with a lot of repos. I even contributed five or so issues to fix some problems with its multiple content root support, a feature I gathered not many people used. The biggest issue is the same one that VS Code had: the missing buffer abstraction. Everything had its own hotkeys, which where modifiers and random keys so hard to remember. Even though I was fast moving around and between files, I did everything else clicking around the UI. I used GoLand for more than a year. Probably the longest I had used an editor since my almost two year Spacemacs stint.

*** Neovim (ft. Lisp)
I decided that I wanted a buffer based editor with a great terminal interface that I could configure in Lisp. So I choose Neovim. I dove deep into the Neovim 0.5 Lua features, even going as far to decide to use Fennel for my configuration, in order to make it insanely hard to write since there were like 20 of us. I spent so much time writing this Fennel code, which as of the writing this section I just deleted, to do silly things like setup the modeline. I remember spending a lot of time on that. A lot of time on which-key. A lot of time screwing with nix packages and packer. Hey, it was something to do.

*** Emacs (Current)
I had been deep in my Nix config for a bit when I started seeing Doom Emacs in the wild a bunch. I forget what really was the deciding factor in trying it, but I did. I installed a bunch of modules, and decided to get deep into Org, and fell in love. Org-mode finally gave my the unification between my development and productivity workflows. I'm still working on my editor, just now while writing this I disabled company mode, which made typing prose way less clunky, but I have become a committed member of the Church of Plaintext. I can't wait to do all my budgeting in BeanCount.

** Goals of the Configuration
This configuration has two primary goals:

1. Setup the editing experience such that I have the same level of agility to move around and between files as I did in NeoVim with plugins like =Telscope.nvim= and =Lightspeed.nvim=.
2. Design a productivity workflow around =org-mode= that I can use to track tasks and knowledge.

*** Improvements from NeoVim
There are some aspects of my NeoVim flow that I did not fine tune that I am going to solve in this configuration.

- I would open files that were not in the current project using ~:e /full/path/to/file~.
- I did all file and git management with the command line.
- I had no real way of managing projects.

** Tools
While Emacs is what I will be spending most of my time in, I will require other tools to work with my tasks and notes while on the go.

*** Using
I've already gotten some tools integrated into my workflow.

- [[https://www.gnu.org/software/emacs/][Emacs]] :: Duh
- [[https://beorgapp.com][beorg]] :: Primary iOS productivity app with a nice widget.

*** To Evaluate
There are tools that are interesting, primarily mobile tools, that I'd like to evaluate and potentially add to my workflow once I get the core Emacs (and my 30o other projects) squared away.

- [[https://plainorg.com][Plain Org]]  :: App to work with and edit org files on the go.
- [[https://flathabits.com][Flat Habits]] :: App for habit tracking using org as the backend.
- [[https://obsidian.md][Obsidian]] :: A cross-platform tool for non-hierarchical notes. Has an org plugin, so might be able to integrate with =org-roam=.
- [[https://logseq.com][Logseq]] :: Tool for working with a non-hierarchical note system. Might be able to integrate with =org-roam=, but might not be.

** References
This configuration is the infusion of refined configurations that people have open sourced that I am slowly adding to based on my needs.

- [[https://www.mtsolitary.com/20210309194647-my-org-mode-setup/][Mt. Solitarity org/roam workflow]]: A blog post explaining a good workflow with ~org-mode~ and related plugins.
- [[https://yiming.dev/blog/2018/03/02/my-org-refile-workflow/][Org Refile Workflow]]
- [[https://coredumped.dev/2021/05/26/taking-org-roam-everywhere-with-logseq/][Org Roam + LogSeq]]
- [[https://rgoswami.me/posts/org-note-workflow/][Orgmode Note Workflow]]
- [[https://config.daviwil.com/workflow][Orgmode Workflow]]
- [[https://blog.calebjay.com/posts/my-emacs-environment/#on-productivity-in-emacs][Productivity in Emacs]]
- [[https://github.com/tecosaur/emacs-config][Tecnosaur's well structured config]]
- [[https://github.com/daviwil/emacs-from-scratch/blob/master/Emacs.org][Rational Emacs]]
- [[https://github.com/ztlevi/doom-config][ztlevi's blazing fast doom config]]
- [[https://github.com/clintonboys/emacs.d/blob/master/init.org][Mt. Solidarity Org config]]
- [[https://github.com/shaunsingh/nyoom.emacs/blob/main/config.org][Nyoom.emacs]]
- [[https://www.labri.fr/perso/nrougier/GTD/index.html][Great guide on GTD in Org]]

* Doom
[[https://github.com/hlissner/doom-emacs][Doom Emacs]] is the framework this configuration provides. While I debated between using it and a handwritten one based on[[https://github.com/SystemCrafters/rational-emacs][Rational Emacs]], I decided to use Doom for the following reasons:

1. I really like the Doom solution to environment variables. When you sync your configuration, the CLI creates an environment file that caches the current state of your shell, which Emacs reads on start. While you must sync whenever you change a shell variable, you get better performance than using something like [[https://github.com/purcell/exec-path-from-shell][ext-path-from-shell]].
2. The module system gives me access to pre-built configurations for behavior that I want. This saves me a lot of time while I familiarize myself with the plugin ecosystem, interactions, and configurations.

** File Bootstrap
Doom has three configuration files. They each need a header comment for things like [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][lexical binding]] and [[https://www.emacswiki.org/emacs/CompiledFile#ByteCompilation][byte compilation]], and ~init.el~ needs the ~doom!~ macro scaffolding.

1. ~init.el~ tells Doom what modules to load.

#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-
(setq byte-compile-warnings '(cl-functions))

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>)
#+end_src
   
2. ~config.el~ provides additional user configuration. We want all configuration to have access to the external library files.

#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
(add-to-list 'load-path (expand-file-name "lisp" (getenv "DOOMDIR")))
#+end_src

3. ~packages.el~ tells Doom which versions and additional packages to use (or not use).

#+begin_src emacs-lisp :tangle packages.el :comments no
;;; -*- no-byte-compile: t; -*-
#+end_src

4. ~cli.el~ applies only when the ~doom~ CLI opens Emacs.

#+begin_src emacs-lisp :tangle "cli.el" :comments no
;;; cli.el -*- lexical-binding: t; -*-
(add-to-list 'load-path (expand-file-name "lisp" (getenv "DOOMDIR")))
#+end_src

** GUI
*** Fonts
Load the fonts configured in the environment at sync time.

#+name: load-fonts
#+begin_src emacs-lisp :tangle no
`(setq doom-font (font-spec :family ,(getenv "FONT_MONOSPACE") ':size 14)
       doom-big-font (font-spec :famil ,(getenv "FONT_MONOSPACE") :size 24)
       doom-unicode-font (font-spec :family ,(getenv "FONT_UNICODE"))
       doom-variable-pitch-font (font-spec :family ,(getenv "FONT_SANS"))
       doom-serif-font (font-spec :family ,(getenv "FONT_SERIF")))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<load-fonts()>>
#+end_src

*** Theme
Load the theme from the environment at sync time.

#+name: load-theme
#+begin_src emacs-lisp :tangle no
`(setq doom-theme (intern ,(getenv "EMACS_THEME")))
#+end_src


#+begin_src emacs-lisp :noweb no-export
<<load-theme()>>
#+end_src

Also set theme-specific settings and move the hooks. Theme-specific settings are fine even if the theme they're for is not in use. The settings will just have no impact.

#+begin_src emacs-lisp
(setq doom-nord-padded-modeline nil)
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
(delq! t custom-theme-load-path)
#+end_src

*** Modeline
#+begin_src emacs-lisp :noweb no-export
(require 'lib-modeline)

(after! doom-modeline
  <<modeline-core>>

  <<modeline-encoding>>

  <<modeline-pdf>>)
#+end_src

Some basic UI customizations to make it a little less crowded.

#+name: modeline-core
#+begin_src emacs-lisp :tangle no
(setq doom-modeline-major-mode-icon t
      doom-modeline-buffer-file-name-style 'truncate-with-project
      doom-modeline-modal-icon t
      inhibit-compacting-font-caches t)

(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   (doom-modeline-spc)
   (doom-modeline--buffer-name)))
#+end_src

Everything is basically =UTF-8= these days. There is no reason to display the current file encoding in the modeline unless its something that is not that.

#+name: modeline-encoding
#+begin_src emacs-lisp :tangle no
(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src

Make the PDF modeline better by using the name and icon.

#+name: modeline-pdf
#+begin_src emacs-lisp :tangle no
(doom-modeline-def-segment pdf-icon
  "PDF icon from all-the-icons."
  (concat (doom-modeline-spc) (doom-modeline--pdf-icon)))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

*** Dashboard
#+begin_src emacs-lisp
(require 'lib-dashboard)
#+end_src

The default dashboard keybindings are a bit too long, and the config option should use the literate config.

#+begin_src emacs-lisp
(map! :map +doom-dashboard-mode-map
      :ne "f" #'find-file
      :ne "r" #'consult-recent-file
      :ne "p" #'doom/open-private-config
      :ne "c" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
      :ne "." (cmd! (doom-project-find-file "~/Projects"))
      :ne "b" #'+vertico/switch-workspace-buffer
      :ne "B" #'consult-buffer
      :ne "q" #'save-buffers-kill-terminal)
#+end_src

Remove some unneeded bits from the dashboard, specifically the menu, modeline, and evil cursor indicator.

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

Let's replace the default GUI Doom splash screen with Tecosaur's nice and simple one with a phrase straight from a video game loading screen.

#+begin_src emacs-lisp
(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n\n"
   (propertize
    (+doom-dashboard--center
     +doom-dashboard--width
     (doom-display-benchmark-h 'return))
    'face 'doom-dashboard-loaded)
   "\n"
   (doom-dashboard-phrase)
   "\n"))
#+end_src

Also add a nicer splash screen for the console.

#+begin_src emacs-lisp
(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

** Settings
*** CLI
Make it so tangling the literate configuration does not require answering a prompt.

#+begin_src emacs-lisp :tangle "cli.el"
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)

(setq org-id-locations-file (expand-file-name "org-id-locations" doom-cache-dir))
#+end_src

*** Buffers
Make the buffer names just slightly nicer. Its the little things.

#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "► Doom"
      +doom-dashboard-name "► Doom")
#+end_src

*** Abbrev
Use one abbreviation file for everything across all

#+begin_src emacs-lisp
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
            (setq-default abbrev-mode t)
            (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src

* Settings
** General
Read the user information from the environment during the sync.

#+name: load-info
#+begin_src emacs-lisp :tangle no
`(setq user-full-name ,(getenv "GITHUB_USER")
       user-mail-address ,(getenv "GITHUB_EMAIL"))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<load-info()>>
#+end_src

Since Doom owns =EMACSDIR=, move the authentication cache file to the home directory. Now, we can freely remove, update, and reset the =EMACSDIR= without losing cached authentication information.

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil)
#+end_src

Relative line numbers are essential. How do you even move around without them? They also terrify people who don't use them. I should probably just get better at toggling them when I'm on screen share. There's a hot key for it even.

#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

General settings that I have stolen from other configs.

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "…"                ; Unicode ellispis are nicer than "...", and also save /precious/ space
      password-cache-expiry nil                   ; I can trust my computers ... can't I?
      scroll-margin 2)                            ; It's nice to maintain a little margin

(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src

Put changes from the customization UI in a separate file instead of =init.el=.

#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))

(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

*** File Templates
Overwrite the default snippet directories for some file types.

#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src

*** Native Compilation
Now that the [[https://github.com/railwaycat/homebrew-emacsmacport][Famous Emacs Mac Port]] has support for native compilation, we got the speed pickup from both mac metal and native compilation.

#+begin_src emacs-lisp
(when 'native-comp-compiler-options
  (setq native-comp-compiler-options '("-O3")))
#+end_src


*** Fix "Package 'cl' is deprecated"
This is a hack that Hlissner officially "recommended" on the Doom discourse [[https://discourse.doomemacs.org/t/warning-at-startup-package-cl-is-deprecated/60][here]]. Package authors should replace ~(require 'cl)~ with ~(require 'cl-lib)~, but that is out of my our control.

#+begin_src emacs-lisp
(defadvice! fixed-do-after-load-evaluation (abs-file)
  :override #'do-after-load-evaluation
  (dolist (a-l-element after-load-alist)
    (when (and (stringp (car a-l-element))
               (string-match-p (car a-l-element) abs-file))
      (mapc #'funcall (cdr a-l-element))))
  (run-hook-with-args 'after-load-functions abs-file))
#+end_src


** GUI
Disable most of the GUI to keep it simple.

#+begin_src emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode 0)
(fringe-mode 0)
#+end_src

*** Window Title
Set the window title to the buffer name and project folder. Also remove the org roam id prefix from the filename.

#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src

** TRAMP
Since I use Nix on most machines, tell Tramp how to find the shell executables.

#+begin_src emacs-lisp
(after! tramp
  (appendq! tramp-remote-path
            '("/run/current-system/profile/bin"
              "/run/current-system/profile/sbin")))
#+end_src

* Modules
** App
#+name: doom-app
#+begin_src emacs-lisp :tangle no
calendar
everywhere
;; irc
(rss +org)
;; twitter
#+end_src

*** Calendar


*** RSS
#+begin_src emacs-lisp
(add-to-list 'rmh-elfeed-org-files (expand-file-name "elfeed.org" org-directory ))
#+end_src

** Checkers
Modules that know what you meant.

#+name: doom-checkers
#+begin_src emacs-lisp :tangle no
syntax
(:if (executable-find "aspell") spell)
grammar
#+end_src

*** Spell
Set the personal dictionaries.

#+begin_src emacs-lisp
(setq ispell-personal-dictionary (expand-file-name ".ispell_personal" doom-private-dir))
#+end_src

** Completion
Use the most modern completion plugins, which is currently [[https://company-mode.github.io][company-mode]] for code completion and [[https://github.com/minad/vertico][vertico]] for the completion UI.

#+name: doom-completion
#+begin_src emacs-lisp :tangle no
(company +childframe)
(vertico +icons)
#+end_src

*** Company
Speed up company.

#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.1
        company-minimum-prefix-length 1
        company-select-wrap-around t
        company-require-match 'never
        company-dabbrev-downcase nil
        company-dabbrev-ignore-case t
        company-dabbrev-other-buffers nil
        company-tooltip-limit 5
        company-tooltip-minimum-width 40)

  (set-company-backend!
    '(text-mode
      markdown-mode
      gfm-mode)
    '(:seperate
      company-files
      company-yasnippet))
  ;; (add-hook 'evil-normal-state-entry-hook #'company-abort)
  ) ;; make aborting less annoying.

;; (setq-default history-length 1000)
;; (setq-default prescient-history-length 1000)
#+end_src

*** Vertico
Make marginalia look way nicer.

#+begin_src emacs-lisp
(after! marginalia
  (setq marginalia-censor-variables nil)

  (defadvice! +marginalia--anotate-local-file-colorful (cand)
    "Just a more colourful version of `marginalia--anotate-local-file'."
    :override #'marginalia--annotate-local-file
    (when-let (attrs (file-attributes (substitute-in-file-name
                                       (marginalia--full-candidate cand))
                                      'integer))
      (marginalia--fields
       ((marginalia--file-owner attrs)
        :width 12 :face 'marginalia-file-owner)
       ((marginalia--file-modes attrs))
       ((+marginalia-file-size-colorful (file-attribute-size attrs))
        :width 7)
       ((+marginalia--time-colorful (file-attribute-modification-time attrs))
        :width 12))))

  (defun +marginalia--time-colorful (time)
    (let* ((seconds (float-time (time-subtract (current-time) time)))
           (color (doom-blend
                   (face-attribute 'marginalia-date :foreground nil t)
                   (face-attribute 'marginalia-documentation :foreground nil t)
                   (/ 1.0 (log (+ 3 (/ (+ 1 seconds) 345600.0)))))))
      ;; 1 - log(3 + 1/(days + 1)) % grey
      (propertize (marginalia--time time) 'face (list :foreground color))))

  (defun +marginalia-file-size-colorful (size)
    (let* ((size-index (/ (log10 (+ 1 size)) 7.0))
           (color (if (< size-index 10000000) ; 10m
                      (doom-blend 'orange 'green size-index)
                    (doom-blend 'red 'orange (- size-index 1)))))
      (propertize (file-size-human-readable size) 'face (list :foreground color)))))
#+end_src

** Config
The core configuration modules that include Doom defaults and enables config tangling.

#+name: doom-config
#+begin_src emacs-lisp :tangle no
literate
(default +bindings +smartparens)
#+end_src

*** Literate
Use Tecosaur's async config tangling setup.

#+begin_src emacs-lisp
(defvar +literate-tangle--proc nil)
(defvar +literate-tangle--proc-start-time nil)

(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (unless (getenv "__NOTANGLE")
    (let ((default-directory doom-private-dir))
      (when +literate-tangle--proc
        (message "Killing outdated tangle process...")
        (set-process-sentinel +literate-tangle--proc #'ignore)
        (kill-process +literate-tangle--proc)
        (sit-for 0.3)) ; ensure the message displays for a bit
      (setq +literate-tangle--proc-start-time (float-time)
            +literate-tangle--proc
            (start-process "tangle-config"
                           (get-buffer-create " *tangle config*")
                           "emacs" "--batch" "--eval"
                           (format "(progn \
(require 'ox) \
(require 'ob-tangle) \
(setq org-confirm-babel-evaluate nil \
      org-inhibit-startup t \
      org-mode-hook nil \
      write-file-functions nil \
      before-save-hook nil \
      after-save-hook nil \
      vc-handled-backends nil \
      org-startup-folded nil \
      org-startup-indented nil) \
(org-babel-tangle-file \"%s\" \"%s\"))"
                                   +literate-config-file
                                   (expand-file-name (concat doom-module-config-file ".el")))))
      (set-process-sentinel +literate-tangle--proc #'+literate-tangle--sentinel)
      (run-at-time nil nil (lambda () (message "Tangling config.org"))) ; ensure shown after a save message
      "Tangling config.org...")))

(defun +literate-tangle--sentinel (process signal)
  (cond
   ((and (eq 'exit (process-status process))
         (= 0 (process-exit-status process)))
    (message "Tangled config.org sucessfully (took %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))
   ((memq (process-status process) (list 'exit 'signal))
    (+popup-buffer (get-buffer " *tangle config*"))
    (message "Failed to tangle config.org (after %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))))

(defun +literate-tangle-check-finished ()
  (when (and (process-live-p +literate-tangle--proc)
             (yes-or-no-p "Config is currently retangling, would you please wait a few seconds?"))
    (switch-to-buffer " *tangle config*")
    (signal 'quit nil)))
(add-hook! 'kill-emacs-hook #'+literate-tangle-check-finished)
#+end_src

*** Default
Change [[https://github.com/abo-abo/avy][Avy]] keybindings to Colemak home row.

#+begin_src emacs-lisp
(after! avy
  (setq avy-keys '(?n ?e ?i ?s ?r ?i ?a)))
#+end_src

Don't cache projectile source directories.

#+begin_src emacs-lisp
(setq projectile-ignored-projects '("~/" "/tmp" "~/.local/share/doom/straight/repos/"))

(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src

**** Smart Parenthesis
Make work for =noweb= links in ~org~ files.

#+begin_src emacs-lisp
(sp-local-pair
 '(org-mode)
 "<<" ">>"
 :actions '(insert))
#+end_src

** Editor
These modules all add functionality for editing text, most notably [[https://github.com/emacs-evil/evil][Evil]], which adds vim-like modal editing to Emacs.

#+name: doom-editor
#+begin_src emacs-lisp :tangle no
(evil +everywhere)
file-templates
fold
(format +onsave)
rotate-text
snippets
;; word-wrap
#+end_src

*** Format
Use the latest format-all plugin.

#+begin_src emacs-lisp :tangle packages.el
(unpin! format-all)
#+end_src

*** Evil
Split windows the correct way.

#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

Quick window navigation with arrow keys.

#+begin_src emacs-lisp
(map!
 ;; Navigation
 "C-<left>" #'evil-window-left
 "C-<right>" #'evil-window-right
 "C-<up>" #'evil-window-up
 "C-<down>" #'evil-window-down

 ;; Swap windows
 "C-S-<left>" #'+evil/window-move-left
 "C-S-<right>" #'+evil/window-move-right
 "C-S-<up>" #'+evil/window-move-up
 "C-S-<down>" #'+evil/window-move-down)
#+end_src

Snipe across all visual characters.

#+begin_src emacs-lisp
(setq evil-snipe-scope 'visible)
#+end_src

*** Snippet
Enable nested snippets.

#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

** Emacs
Modules that configure builtin tools such as [[https://www.emacswiki.org/emacs/DiredMode][Dired]] and [[https://www.emacswiki.org/emacs/IbufferMode][IBuffer]].

#+name: doom-emacs
#+begin_src emacs-lisp :tangle no
(dired +ranger +icons)
electric
(ibuffer +icons)
(undo +tree)
vc
#+end_src

*** VC
Use transient for repeated operations.

#+begin_src emacs-lisp
(defun smerge-repeatedly ()
  "Perform smerge actions again and again"
  (interactive)
  (smerge-mode 1)
  (smerge-transient))

(after! transient
  (transient-define-prefix smerge-transient ()
    [["Move"
      ("n" "next" (lambda () (interactive) (ignore-errors (smerge-next)) (smerge-repeatedly)))
      ("p" "previous" (lambda () (interactive) (ignore-errors (smerge-prev)) (smerge-repeatedly)))]
     ["Keep"
      ("b" "base" (lambda () (interactive) (ignore-errors (smerge-keep-base)) (smerge-repeatedly)))
      ("u" "upper" (lambda () (interactive) (ignore-errors (smerge-keep-upper)) (smerge-repeatedly)))
      ("l" "lower" (lambda () (interactive) (ignore-errors (smerge-keep-lower)) (smerge-repeatedly)))
      ("a" "all" (lambda () (interactive) (ignore-errors (smerge-keep-all)) (smerge-repeatedly)))
      ("RET" "current" (lambda () (interactive) (ignore-errors (smerge-keep-current)) (smerge-repeatedly)))]
     ["Diff"
      ("<" "upper/base" (lambda () (interactive) (ignore-errors (smerge-diff-base-upper)) (smerge-repeatedly)))
      ("=" "upper/lower" (lambda () (interactive) (ignore-errors (smerge-diff-upper-lower)) (smerge-repeatedly)))
      (">" "base/lower" (lambda () (interactive) (ignore-errors (smerge-diff-base-lower)) (smerge-repeatedly)))
      ("R" "refine" (lambda () (interactive) (ignore-errors (smerge-refine)) (smerge-repeatedly)))
      ("E" "ediff" (lambda () (interactive) (ignore-errors (smerge-ediff)) (smerge-repeatedly)))]
     ["Other"
      ("c" "combine" (lambda () (interactive) (ignore-errors (smerge-combine-with-next)) (smerge-repeatedly)))
      ("r" "resolve" (lambda () (interactive) (ignore-errors (smerge-resolve)) (smerge-repeatedly)))
      ("k" "kill current" (lambda () (interactive) (ignore-errors (smerge-kill-current)) (smerge-repeatedly)))
      ("q" "quit" (lambda () (interactive) (smerge-auto-leave)))]]))
#+end_src

** Email
Now I can answer emails even slower in Emacs.

#+name: doom-email
#+begin_src emacs-lisp :tangle no
(mu4e +org +gmail)
#+end_src

*** mu4e
:PROPERTIES:
:ID:                     19e6ee5c-d9f3-4de7-8876-8b7dcdb05c4f
:END:
First, add the mu4e package to the load path. This is because its installed with mu, not as an emacs package.

#+begin_src emacs-lisp :noweb no-export
(add-to-list 'load-path "~/.local/share/emacs/site-lisp/mu4e")

(after! mu4e
  <<mu4e-core>>

  <<mu4e-contexts>>

  <<mu4e-bookmarks>>

  <<mu4e-reindex>>

  <<mu4e-ui>>)
#+end_src

Set some basic configuration options.

#+name: mu4e-core
#+begin_src emacs-lisp :tangle no
(setq mu4e-maildir "~/Mail"
      mu-4e-context-policy 'pick-first
      mu4e-update-interval (* 10 60)
      mu4e-completing-read-function #'ivy-completing-read
      mu4e-view-prefer-html t)

#+end_src

Create a context for each of my email accounts.

#+name: mu4e-contexts
#+begin_src emacs-lisp :tangle no
(setq mu4e-contexts
      (list
       (make-mu4e-context
        :name "Personal"
        :match-func (lambda (msg) (when msg (string-prefix-p "/personal" (mu4e-message-field msg :maildir))))
        :vars '((user-full-name . "Ryan King")
                (user-mail-address . "ryantking@protonmail.com")
                (mu4e-drafts-folder . "/personal/drafts")
                (mu4e-sent-folder . "/personal/sent")
                (mu4e-refile-folder . "/personal/archive")
                (mu4e-trash-folder . "/personal/trash")))
       (make-mu4e-context
        :name "Gmail"
        :match-func (lambda (msg) (when msg (string-prefix-p "/gmail" (mu4e-message-field msg :maildir))))
        :vars '((user-full-name . "Ryan King")
                (user-mail-address . "ryan.taylor.king@gmail.com")
                (mu4e-drafts-folder . "/gmail/drafts")
                (mu4e-sent-folder . "/gmail/sent")
                (mu4e-refile-folder . "/gmail/archive")
                (mu4e-trash-folder . "/gmail/trash")))
       (make-mu4e-context
        :name "Work"
        :match-func (lambda (msg) (when msg (string-prefix-p "/work" (mu4e-message-field msg :maildir))))
        :vars '((user-full-name . "Ryan Taylor King")
                (user-mail-address . "ryking@redhat.com")
                (mu4e-drafts-folder . "/work/drafts")
                (mu4e-sent-folder . "/work/sent")
                (mu4e-refile-folder . "/work/archive")
                (mu4e-trash-folder . "/work/trash")))))
#+end_src

And some bookmarks.

#+name: mu4e-bookmarks
#+begin_src emacs-lisp :tangle no
(add-to-list 'mu4e-bookmarks
             (make-mu4e-bookmark
              :name "All Inboxes"
              :query "maildir:/personal/inbox OR maildir:/gmail/inbox OR maildir:/work/inbox"
              :key ?i))
#+end_src

Add a bit from tecosaur that automatically rebuilds the index.

#+name: mu4e-reindex
#+begin_src emacs-lisp :tangle no
(defvar mu4e-reindex-request-file "/tmp/mu_reindex_now"
  "Location of the reindex request, signaled by existance")

(defvar mu4e-reindex-request-min-seperation 5.0
  "Don't refresh again until this many second have elapsed.
Prevents a series of redisplays from being called (when set to an appropriate value)")

(defvar mu4e-reindex-request--file-watcher nil)
(defvar mu4e-reindex-request--file-just-deleted nil)
(defvar mu4e-reindex-request--last-time 0)

(defun mu4e-reindex-request--add-watcher ()
  (setq mu4e-reindex-request--file-just-deleted nil)
  (setq mu4e-reindex-request--file-watcher
        (file-notify-add-watch mu4e-reindex-request-file
                                '(change)
                                #'mu4e-file-reindex-request)))

(defadvice! mu4e-stop-watching-for-reindex-request ()
  :after #'mu4e~proc-kill
  (if mu4e-reindex-request--file-watcher
      (file-notify-rm-watch mu4e-reindex-request--file-watcher)))

(defadvice! mu4e-watch-for-reindex-request ()
  :after #'mu4e~proc-start
  (mu4e-stop-watching-for-reindex-request)
  (when (file-exists-p mu4e-reindex-request-file)
    (delete-file mu4e-reindex-request-file))
  (mu4e-reindex-request--add-watcher))

(defun mu4e-file-reindex-request (event)
  "Act based on the existance of `mu4e-reindex-request-file'"
  (if mu4e-reindex-request--file-just-deleted
      (mu4e-reindex-request--add-watcher)
    (when (equal (nth 1 event) 'created)
      (delete-file mu4e-reindex-request-file)
      (setq mu4e-reindex-request--file-just-deleted t)
      (mu4e-reindex-maybe t))))

(defun mu4e-reindex-maybe (&optional new-request)
  "Run `mu4e~proc-index' if it's been more than
`mu4e-reindex-request-min-seperation'seconds since the last request,"
  (let ((time-since-last-request (- (float-time)
                                    mu4e-reindex-request--last-time)))
    (when new-request
      (setq mu4e-reindex-request--last-time (float-time)))
    (if (> time-since-last-request mu4e-reindex-request-min-seperation)
        (mu4e~proc-index nil t)
      (when new-request
        (run-at-time (* 1.1 mu4e-reindex-request-min-seperation) nil
                      #'mu4e-reindex-maybe)))))
#+end_src

Some minor UI customization.

#+name: mu4e-ui
#+begin_src emacs-lisp :tangle no
(setq mu4e-headers-fields
      '((:flags . 6)
        (:account-stripe . 2)
        (:from-or-to . 25)
        (:folder . 10)
        (:recipnum . 2)
        (:subject . 80)
        (:human-date . 8))
      +mu4e-min-header-frame-width 142
      mu4e-headers-date-format "%d/%m/%y"
      mu4e-headers-time-format "⧖ %H:%M"
      mu4e-headers-results-limit 1000
      mu4e-index-cleanup t)

(defvar +mu4e-header--folder-colors nil)

(appendq! mu4e-header-info-custom
          '((:folder .
              (:name "Folder" :shortname "Folder" :help "Lowest level folder" :function
              (lambda (msg)
                (+mu4e-colorize-str
                  (replace-regexp-in-string "\\`.*/" "" (mu4e-message-field msg :maildir))
                  '+mu4e-header--folder-colors))))))
#+end_src

** Languages
All the languages I need to edit, at least once in my life, or maybe someday (looking at you ~solidity~).

*UPDATE:* I have written some =Solidity=.

#+name: doom-lang
#+begin_src emacs-lisp :tangle no
data
emacs-lisp
(go +lsp    )
(java +meghanada)
(json +lsp)
(javascript +lsp)
(lua +fennel)
markdown
nix
(org +hugo +journal +pretty +roam2 +dragndrop +noter +pandoc +gnuplot +present)
(rust +lsp)
(sh +lsp)
solidity
(yaml +lsp)
#+end_src

*** Markdown
By default, =markdownlint= doesn't recognize the config file in the repository. We can assume that it'll always be a =YAML= file.

#+begin_src emacs-lisp
(setq-default flycheck-markdown-markdownlint-cli-config ".markdownlint.yaml")
#+end_src

*** Org
My productivity workflow is entirely designed around ~org-mode~.

**** Packages
***** Core Org
Use the latest ~org-mode~ because bugs aren't real.

#+begin_src emacs-lisp :tangle packages.el
(unpin! org-mode)

(package! org-contrib
  :recipe (:host nil :repo "https://git.sr.ht/~bzg/org-contrib"
           :files ("lisp/*.el"))
  :pin "b8012e759bd5bf5da802b0b41734a8fec218323c")
#+end_src
***** Vulpea
:PROPERTIES:
:ID:                     e63d2527-2b11-4cf6-802d-eec8206ef9b6
:END:
Use the fantastic [[https://github.com/d12frosted/vulpea][Vulpea]] for a unified ~org-roam~-based experience.

#+begin_src emacs-lisp :tangle packages.el
(package! vulpea)
#+end_src

#+begin_src emacs-lisp
(use-package! vulpea
  :ensure t
  :hook ((before-save . vulpea-pre-save-hook)
         (org-roam-db-autosync-mode . vulpea-db-autosync-enable))
  :init
  (require 'lib-vulpea)
  (setq vulpea-directory (expand-file-name "~/Dropbox/org/roam"))
  (add-to-list 'window-buffer-change-functions #'vulpea-setup-buffer)
  (add-hook 'vulpea-insert-handle-functions #'vulpea-insert-handle)
  (setq-default
   vulpea-find-default-filter (lambda (note) (= (vulpea-note-level note) 0))
   vulpea-insert-default-filter (lambda (note) (= (vulpea-note-level note) 0))))
#+end_src

Add some =Vulpea= keybindings.

#+begin_src emacs-lisp
(map! :leader
      :prefix "n"
      :desc "Find file" "f" #'vulpea-find
      :desc "Find backlink" "F" #'vulpea-find-backlink
      :desc "Insert note" "i" #'vulpea-insert
      :desc "Tag" "t" #'vulpea-tags-add
      :desc "Untag" "T" #'vulpea-tags-delete)
#+end_src

***** Visuals
Make Org tables better looking.

#+begin_src emacs-lisp :tangle packages.el
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "87772a9469d91770f87bfa788580fca69b9e697a")
#+end_src

#+begin_src emacs-lisp
(use-package! org-pretty-table
  :commands (org-pretty-table-mode global-org-pretty-table-mode))
#+end_src

Use org-appear to show emphasis markers when we enter the text they surround.

#+begin_src emacs-lisp :tangle packages.el
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "148aa124901ae598f69320e3dcada6325cdc2cf0")
#+end_src

#+begin_src emacs-lisp
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

Outline view for headlines.

#+begin_src emacs-lisp :tangle packages.el
(package! org-ol-tree :recipe (:host github :repo "Townk/org-ol-tree")
  :pin "207c748aa5fea8626be619e8c55bdb1c16118c25")
#+end_src

#+begin_src emacs-lisp
(use-package! org-ol-tree
  :commands org-ol-tree)

(map! :map org-mode-map
      :after org
      :localleader
      :desc "Outline" "O" #'org-ol-tree)
#+end_src

***** Extra Functionality
Handle citations nicely.

#+begin_src emacs-lisp :tangle packages.el
(package! org-ref :pin "3ca9beb744621f007d932deb8a4197467012c23a")
#+end_src

Do HTTP requests in org mode.

#+begin_src emacs-lisp :tangle packages.el
(package! ob-http :pin "b1428ea2a63bcb510e7382a1bf5fe82b19c104a7")
#+end_src

#+begin_src emacs-lisp
(use-package! ob-http
  :commands org-babel-execute:http)
#+end_src

Transclude the contents from other org documents.

#+begin_src emacs-lisp :tangle packages.el
(package! org-transclusion :recipe (:host github :repo "nobiot/org-transclusion")
  :pin "8cbbade1e3237200c2140741f39ff60176e703e7")
#+end_src

#+begin_src emacs-lisp
(use-package! org-transclusion
  :commands org-transclusion-mode
  :init
  (map! :after org :map org-mode-map
        "<f12>" #'org-transclusion-mode))
#+end_src

Cool package to handle graphs.

#+begin_src emacs-lisp :tangle packages.el
(package! org-graph-view :recipe (:host github :repo "alphapapa/org-graph-view") :pin "13314338d70d2c19511efccc491bed3ca0758170")
#+end_src

**** Behavior
***** Defaults
#+begin_src emacs-lisp :noweb no-export
(after! org
  <<org-core>>

  <<org-babel>>

  <<org-keywords>>

  <<org-apps>>

  <<org-bindings>>)
#+end_src

Configure the behavior for editing Org files.

#+name: org-core
#+begin_src emacs-lisp :tangle no
(setq org-directory (expand-file-name "~/Dropbox/org")
      org-modules '(org-id org-attach)
      org-log-done 'time
      org-use-property-inheritance t
      org-list-allow-alphabetical t
      org-export-in-background t
      org-catch-invisible-edits 'smart
      org-export-with-sub-superscripts '{}
      org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src

Use some nicer default values for babel stuff.

#+name: org-babel
#+begin_src emacs-lisp :tangle no
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

Configure keywords for org. The first sequence probably won't change all that much, but the second one might become a "type sequence" of sorts for labeling projects, meetings etc.

#+name: org-keywords
#+begin_src emacs-lisp :tangle no
(setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "HOLD(h)" "|" "DONE(d)")
                          (sequence "|" "CANCELLED(c)"))
      org-property-format "%-24s %s"
      org-tag-persistent-alias '(("FOCUS" . ?f) ("PROJECT" . ?p))
      org-tags-exclude-from-inheritance '("project" "people" "upstream" "downstream"))
#+end_src

Open directory links in =dired= and open files in the same window.

#+name: org-apps
#+begin_src emacs-lisp :tangle no
(add-to-list 'org-file-apps '(directory . emacs))
(add-to-list 'org-link-frame-setup '(file . find-file))
(setq org-indirect-buffer-display 'current-window)
#+end_src

Add missing arrow key bindings.

#+name: org-bindings
#+begin_src emacs-lisp :tangle no
(after! org
  (map! :map evil-org-mode-map
        :after evil-org
        :n "g <up>" #'org-backward-heading-same-level
        :n "g <down>" #'org-forward-heading-same-level
        :n "g <left>" #'org-up-element
        :n "g <right>" #'org-down-element))
#+end_src

***** ID
Some settings that make org IDs work more better.

#+begin_src emacs-lisp
(require 'lib-vulpea-id)

(setq org-id-locations-file (expand-file-name "org-id-locations" doom-cache-dir))

(after! org-id
  (add-hook 'before-save #'vuplea-id-auto-assign)
  (add-hook 'org-capture-prepare-finalize #'org-id-get-create)
  (setq org-id-uuid-program "uuidgen | tr \"[:upper:]\" \"[:lower:]\""
        org-id-track-globally t
        org-id-extra-files'((expand-file-name ".archive/archive" org-directory)
                            (expand-file-name ".archive/archive.org" org-directory))
        org-id-link-to-org-use-id t))
#+end_src

***** Clock
Its important to keep track of time spend on tasks.

#+begin_src emacs-lisp
(after! org-clock
  (setq org-clock-persist-file (expand-file-name "org-clock-save.el" doom-etc-dir))
  (add-hook 'kill-emacs-hook #'org-clock-save))
#+end_src

***** Agenda
Setup the calendar using ~org-gcal~:

#+name: org-gcal
#+begin_src emacs-lisp :tangle no
`(setq org-gcal-client-id "613018054642-vsjcnrqaf8vkdm7m3s5ahmvr8rfbat31.apps.googleusercontent.com"
       org-gcal-client-secret ,(string-trim-right (shell-command-to-string "pass oauth/rh-emacs-sync") "\n")
       org-gcal-fetch-file-alist '(("ryking@redhat.com" .  ,(expand-file-name "~/Dropbox/org/cal/work.org"))
                                   ("ryan.taylor.king@gmail.com" .  ,(expand-file-name "~/Dropbox/org/cal/personal.org"))))
#+end_src

#+begin_src emacs-lisp :noweb no-export
(require 'org-gcal)

<<org-gcal()>>
#+end_src

Configure =org-gcal= to add a timestamp to all events so they show up on the org agenda properly. Note that we cannot use ~SCHEDULED:~ here because it will remain on the agenda until we mark it as cone. Even if it is not a task.

#+begin_src emacs-lisp
(defun org-gcal--add-timestamp (_calendar-id event _update-mode)
  (when (not (org-gcal--event-cancelled-p event))
    (org-back-to-heading)
    (org-narrow-to-element)
    (when (re-search-forward
           (format "^[ \t]*:%s:[ \t]*$" org-gcal-drawer-name)
           (point-max)
           'noerror)
      (forward-line 1)
      (when
          (re-search-forward org-element--timestamp-regexp (point-at-eol) 'noerror)
        (replace-match (concat "<" (match-string 1) " " "-1d" ">"))))))

(add-hook 'org-gcal-after-update-entry-functions #'org-gcal--add-timestamp)
#+end_src

Configure the org agenda using [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]].

#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda :pin "a5557ea4f51571ee9def3cd9a1ab1c38f1a27af7")
#+end_src

#+begin_src emacs-lisp
(after! org-agenda (require 'init-agenda))
#+end_src

***** Roam
Set the =org-roam= basic settings.

#+begin_src emacs-lisp
(setq org-roam-directory vulpea-directory
      org-roam-dailies-directory (expand-file-name "journal/" org-directory)
      org-roam-completion-everywhere t)
#+end_src

Make the modeline look  little bit better for roam notes.

#+begin_src emacs-lisp
(defadvice! doom-modeline--buffer-file-name-roam-aware-a (orig-fun)
  :around #'doom-modeline-buffer-file-name ; takes no args
  (if (s-contains-p org-roam-directory (or buffer-file-name ""))
      (replace-regexp-in-string
       "\\(?:^\\|.*/\\)\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)[0-9]*-"
       "🢔(\\1-\\2-\\3) "
       (subst-char-in-string ?_ ?  buffer-file-name))
    (funcall orig-fun)))
#+end_src

Add in the roam UI that's a little nicer than the built in one with graphviz. Would be nice get it working with the internal Emacs web browser.

#+begin_src emacs-lisp :tangle packages.el
(package! org-roam-ui :recipe (:host github :repo "org-roam/org-roam-ui" :files ("*.el" "out")) :pin "c93f6b61a8d3d2edcf07eda6220278c418d1054b")
(package! websocket :pin "fda4455333309545c0787a79d73c19ddbeb57980") ; dependency of `org-roam-ui'
#+end_src

#+begin_src emacs-lisp
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :commands org-roam-ui-open
  :hook (org-roam . org-roam-ui-mode)
  :config
  (require 'org-roam) ; in case autoloaded
  (defun org-roam-ui-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (unless org-roam-ui-mode (org-roam-ui-mode 1))
    (browse-url-xdg-open (format "http://localhost:%d" org-roam-ui-port))))
#+end_src

***** Capture
:PROPERTIES:
:ID:                     37255dad-fe3f-4baf-b976-fcc5dd3a440d
:END:
I will be using [[https://github.com/progfolio/doct][DOCT]] for my capture templates.

#+begin_src emacs-lisp :tangle packages.el
(package! doct
  :recipe (:host github :repo "progfolio/doct")
  :pin "67fc46c8a68989b932bce879fbaa62c6a2456a1f")
#+end_src

#+begin_src emacs-lisp :noweb no-export
(after! org-roam (require 'init-capture))
#+end_src

Fix ~org-capture~ CLI.

#+begin_src emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
;; (alist-get 'name +org-capture-frame-parameters) "❖ Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+end_src

***** Refile
Easily refile to the project management org file.

#+begin_src emacs-lisp
(after! org-refile
  (require 'lib-vulpea-refile)
  (setq org-outline-path-complete-in-steps nil
        org-refile-targets '((nil :maxlevel . 4)
                             (org-agenda-files :maxlevel . 4))
        org-refile-use-outline-path t
        org-refile-allow-creating-parent-nodes nil
        org-refile-target-verify-function #'vulpea-refile-verify-target))
#+end_src

***** Archive
Easily archive notes that are no longer needed because deleting them is off the table.

#+begin_src emacs-lisp
(after! org-archive
  (setq-default org-achive-location (concat org-directory ".archive/%s_archive" "::" "datetree/*")
                org-archive-save-context-info '(item file ltags itags todo category olpath)))
#+end_src

***** Journal
Write some feels down with the journal.

#+begin_src emacs-lisp
(after! org-journal
  (setq
   org-journal-date-prefix "#+title: "
   org-journal-file-format "%Y-%m-%d.org"
   org-journal-dir (expand-file-name "~/Dropbox/org/journal")
   org-journal-date-format "%Y-%m-%d"))
#+end_src

***** Fix Problematic Hooks
#+begin_src elisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
  (ignore-errors (apply orig-fn args)))
#+end_src
**** Visuals
***** Fonts
Use mixed pitch via =+org-pretty-mode=.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

Increase header size.

#+begin_src emacs-lisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

Increase title size.

#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src

Make deadlines colored like errors.

#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

Put quotes in italics.

#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

Speed up large files by deferring font locking.

#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src

***** Fontify SRC Blocks

#+begin_src emacs-lisp
(defvar org-prettify-inline-results t
  "Whether to use (ab)use prettify-symbols-mode on {{{results(...)}}}.
Either t or a cons cell of strings which are used as substitutions
for the start and end of inline results, respectively.")

(defvar org-fontify-inline-src-blocks-max-length 200
  "Maximum content length of an inline src block that will be fontified.")

(defun org-fontify-inline-src-blocks (limit)
  "Try to apply `org-fontify-inline-src-blocks-1'."
  (condition-case nil
      (org-fontify-inline-src-blocks-1 limit)
    (error (message "Org mode fontification error in %S at %d"
                    (current-buffer)
                    (line-number-at-pos)))))

(defun org-fontify-inline-src-blocks-1 (limit)
  "Fontify inline src_LANG blocks, from `point' up to LIMIT."
  (let ((case-fold-search t)
        (initial-point (point)))
    (while (re-search-forward "\\_<src_\\([^ \t\n[{]+\\)[{[]?" limit t) ; stolen from `org-element-inline-src-block-parser'
      (let ((beg (match-beginning 0))
            pt
            (lang-beg (match-beginning 1))
            (lang-end (match-end 1)))
        (remove-text-properties beg lang-end '(face nil))
        (font-lock-append-text-property lang-beg lang-end 'face 'org-meta-line)
        (font-lock-append-text-property beg lang-beg 'face 'shadow)
        (font-lock-append-text-property beg lang-end 'face 'org-block)
        (setq pt (goto-char lang-end))
        ;; `org-element--parse-paired-brackets' doesn't take a limit, so to
        ;; prevent it searching the entire rest of the buffer we temporarily
        ;; narrow the active region.
        (save-restriction
          (narrow-to-region beg (min (point-max) limit (+ lang-end org-fontify-inline-src-blocks-max-length)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\[))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (point) 'face 'org-block)
            (setq pt (point)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\{))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (1+ pt) 'face '(org-block shadow))
            (unless (= (1+ pt) (1- (point)))
              (if org-src-fontify-natively
                  (org-src-font-lock-fontify-block (buffer-substring-no-properties lang-beg lang-end) (1+ pt) (1- (point)))
                (font-lock-append-text-property (1+ pt) (1- (point)) 'face 'org-block)))
            (font-lock-append-text-property (1- (point)) (point) 'face '(org-block shadow))
            (setq pt (point))))
        (when (and org-prettify-inline-results (re-search-forward "\\= {{{results(" limit t))
          (font-lock-append-text-property pt (1+ pt) 'face 'org-block)
          (goto-char pt))))
    (when org-prettify-inline-results
      (goto-char initial-point)
      (org-fontify-inline-src-results limit))))

(defun org-fontify-inline-src-results (limit)
  (while (re-search-forward "{{{results(\\(.+?\\))}}}" limit t)
    (remove-list-of-text-properties (match-beginning 0) (point)
                                    '(composition
                                      prettify-symbols-start
                                      prettify-symbols-end))
    (font-lock-append-text-property (match-beginning 0) (match-end 0) 'face 'org-block)
    (let ((start (match-beginning 0)) (end (match-beginning 1)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟨" (car org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))
    (let ((start (match-end 1)) (end (point)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟩" (cdr org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))))

(defun org-fontify-inline-src-blocks-enable ()
  "Add inline src fontification to font-lock in Org.
Must be run as part of `org-font-lock-set-keywords-hook'."
  (setq org-font-lock-extra-keywords
        (append org-font-lock-extra-keywords '((org-fontify-inline-src-blocks)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-fontify-inline-src-blocks-enable)
#+end_src

***** Symbols
Better bullets ans other symbols.

#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-superstar-prettify-item-bullets t))

(setq org-ellipsis " ▾ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src

Unicode characters for check boxes and other commands.

#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          `(:checkbox      "☐"
            :pending       "◼"
            :checkedbox    "☑"
            :list_property "∷"
            :em_dash       "—"
            :ellipses      "…"
            :arrow_right   "→"
            :arrow_left    "←"
            :title         "𝙏"
            :subtitle      "𝙩"
            :author        "𝘼"
            :date          "𝘿"
            :property      "☸"
            :options       "⌥"
            :startup       "⏻"
            :macro         "𝓜"
            :html_head     "🅷"
            :html          "🅗"
            :latex_class   "🄻"
            :latex_header  "🅻"
            :beamer_header "🅑"
            :latex         "🅛"
            :attr_latex    "🄛"
            :attr_html     "🄗"
            :attr_org      "⒪"
            :begin_quote   "❝"
            :end_quote     "❞"
            :caption       "☰"
            :header        "›"
            :results       "🠶"
            :begin_export  "⏩"
            :end_export    "⏪"
            :properties    "⚙"
            :end           "∎"
            :priority_a   ,(propertize "⚑" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "⬆" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "■" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "⬇" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "❓" 'face 'all-the-icons-blue)))

(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]")

(plist-put +ligatures-extra-symbols :name "⁍")
#+end_src

*** Go
Use gofumpt.

#+begin_src emacs-lisp
(setq lsp-go-use-gofumpt t)
#+end_src

** OS
Modules that interact with the OS.

#+name: doom-os
#+begin_src emacs-lisp :tangle no
(:if IS-MAC macos)
(tty +osc)
#+end_src

** Terminal
I currently have both [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]] and [[https://github.com/akermu/emacs-libvterm][Vterm]] enabled. I'm removing my dependence on a terminal emulator by adding tools such as ~magit~, ~treemacs~, and the compile command to my workflow. Eventually, I would like to use ~eshell~ for the times when I do still need a terminal emulator since it uses Emacs functionality instead of CLI tools like ~fzf~.

#+name: doom-term
#+begin_src emacs-lisp :tangle no
eshell
vterm
#+end_src

*** VTerm
Fix bug with native compilation.

#+begin_src emacs-lisp
(setq vterm-always-compile-module t)
#+end_src

Kill buffer on exit without prompt.

#+begin_src emacs-lisp
(setq vterm-kill-buffer-on-exit t)
#+end_src

Use ligatures.

#+begin_src emacs-lisp
(setq +ligatures-in-modes t)
(setq +ligatures-extras-in-modes '(org-mode emacs-lisp-mode))
#+end_src

** Tools
Modules that add external tools to Emacs.
#+name: doom-tools
#+begin_src emacs-lisp :tangle no
       ansible
       (debugger +lsp)
       direnv
       (docker +lsp)
       editorconfig
       (eval +overlay)
       gist
       (lookup +devdocs +docsets)
       (lsp +peek)
       (magit +forge)
       make
       pdf
       rgb
       taskrunner
       upload
#+end_src

*** LSP
Use latest LSP plugins.

#+begin_src emacs-lisp :tangle packages.el
(unpin! lsp-ui)
(unpin! lsp-mode)
#+end_src

Better LSP UI.

#+begin_src emacs-lisp
(use-package! lsp-ui
  :hook (lsp-mode . lsp-ui-mode)
  :config
  (setq lsp-lens-enable t
        lsp-ui-doc-enable t
        lsp-ui-sideline-enable nil
        lsp-enable-symbol-highlighting t
        lsp-enable-semantic-tokens-enable t
        lsp-headerline-breadcrumb-enable nil
        ;; lsp-ui-peek-enable t
        ;; lsp-ui-peek-fontify 'on-demand
        ))
#+end_src

Support Nix LSP:

#+begin_src emacs-lisp
(with-eval-after-load 'lsp-mode
  (add-to-list 'lsp-language-id-configuration '(nix-mode . "nix"))
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection '("rnix-lsp"))
                    :major-modes '(nix-mode)
                    :server-id 'nix)))
#+end_src

** UI
This category contains both general UI things such as the ~modeline~ and "buffer-specific" things such as ~hl-todo~.

#+name: doom-ui
#+begin_src emacs-lisp :tangle no
doom
doom-dashboard
doom-quit
(:if IS-LINUX (emoji +unicode +github))
fill-column
hl-todo
(ligatures +extras)
modeline
nav-flash
ophints
(popup +all +defaults)
(treemacs +lsp)
unicode
vc-gutter
(window-select +numbers)
workspaces
zen
#+end_src

*** Emoji
Don't use emojis instead of default characters.

#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
  '(;; Org
    "◼" "☑" "☸" "⚙" "⏩" "⏪" "⬆" "⬇" "❓"
    ;; Terminal powerline
    "✔"
    ;; Box drawing
    "▶" "◀")
  "Characters that should never be affected by `emojify-mode'.")

(defadvice! emojify-delete-from-data ()
  "Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
  :after #'emojify-set-emoji-data
  (dolist (emoji emojify-disabled-emojis)
    (remhash emoji emojify-emojis)))
#+end_src

*** Popup
Speed up the pop-up

#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5)
#+end_src

Remove noise from =evil-= bindings.

#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)

(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))))
#+end_src

*** Themes
Use the latest themes.

#+begin_src emacs-lisp :tangle packages.el
(unpin! doom-themes doom-modeline)
(package! solaire-mode :disable t)
(package! ox-chameleon :recipe (:host github :repo "tecosaur/ox-chameleon"))
#+end_src

*** Treemacs
Ignore superfluous files.

#+begin_src emacs-lisp
(after! treemacs
  (defvar treemacs-file-ignore-extensions '()
    "File extension which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-globs '()
    "Globs which will are transformed to `treemacs-file-ignore-regexps' which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-regexps '()
    "RegExps to be tested to ignore files, generated from `treeemacs-file-ignore-globs'")
  (defun treemacs-file-ignore-generate-regexps ()
    "Generate `treemacs-file-ignore-regexps' from `treemacs-file-ignore-globs'"
    (setq treemacs-file-ignore-regexps (mapcar 'dired-glob-regexp treemacs-file-ignore-globs)))
  (if (equal treemacs-file-ignore-globs '()) nil (treemacs-file-ignore-generate-regexps))
  (defun treemacs-ignore-filter (file full-path)
    "Ignore files specified by `treemacs-file-ignore-extensions', and `treemacs-file-ignore-regexps'"
    (or (member (file-name-extension file) treemacs-file-ignore-extensions)
        (let ((ignore-file nil))
          (dolist (regexp treemacs-file-ignore-regexps ignore-file)
            (setq ignore-file (or ignore-file (if (string-match-p regexp full-path) t nil)))))))
  (add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore-filter))
#+end_src

Identify the files to ignore.

#+begin_src emacs-lisp
(setq treemacs-file-ignore-extensions
      '(;; LaTeX
        "aux"
        "ptc"
        "fdb_latexmk"
        "fls"
        "synctex.gz"
        "toc"
        ;; LaTeX - glossary
        "glg"
        "glo"
        "gls"
        "glsdefs"
        "ist"
        "acn"
        "acr"
        "alg"
        ;; LaTeX - pgfplots
        "mw"
        ;; LaTeX - pdfx
        "pdfa.xmpi"
        ))

(setq treemacs-file-ignore-globs
      '(;; LaTeX
        "*/_minted-*"
        ;; AucTeX
        "*/.auctex-auto"
        "*/_region_.log"
        "*/_region_.tex"))
#+end_src

*** Zen
Setup mixed pitch for certain modes. Use a hook so that it runs after UI initialization.

#+begin_src emacs-lisp
(defvar mixed-pitch-modes '(org-mode LaTeX-mode markdown-mode gfm-mode Info-mode)
  "Modes to enable `mixed-pitch-mode' in, but only after UI initialisation.")

(defun init-mixed-pitch-h ()
  "Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
  (when (memq major-mode mixed-pitch-modes)
    (mixed-pitch-mode 1))
  (dolist (hook mixed-pitch-modes)
    (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))

(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
#+end_src

Use mixed pitch with serif.

#+begin_src emacs-lisp
(after! mixed-pitch
  (defface variable-pitch-serif '((t (:family "serif")))
    "A variable-pitch face with serifs."
    :group 'basic-faces)
  (setq mixed-pitch-set-height t)
  (setq variable-pitch-serif-font (font-spec :family (getenv "FONT_SERIF") :size 16))
  (set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
  (defun mixed-pitch-serif-mode (&optional arg)
    "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
    (interactive)
    (let ((mixed-pitch-face 'variable-pitch-serif))
      (mixed-pitch-mode (or arg 'toggle)))))
#+end_src

Some nice aesthetic tweaks.

#+begin_src emacs-lisp
(defvar +zen-serif-p t
  "Whether to use a serifed font with `mixed-pitch-mode'.")

(after! writeroom-mode
  (defvar-local +zen--original-org-indent-mode-p nil)
  (defvar-local +zen--original-mixed-pitch-mode-p nil)
  (defvar-local +zen--original-org-pretty-table-mode-p nil)

  (defun +zen-enable-mixed-pitch-mode-h ()
    "Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
    (when (apply #'derived-mode-p +zen-mixed-pitch-modes)
      (if writeroom-mode
          (progn
            (setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
            (funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
        (funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1)))))
  (pushnew! writeroom--local-variables
            'display-line-numbers
            'visual-fill-column-width
            'org-adapt-indentation
            'org-superstar-headline-bullets-list
            'org-superstar-remove-leading-stars)
  (add-hook 'writeroom-mode-enable-hook
            (defun +zen-prose-org-h ()
              "Reformat the current Org buffer appearance for prose."
              (when (eq major-mode 'org-mode)
                (setq display-line-numbers nil
                      visual-fill-column-width 60
                      org-adapt-indentation nil)
                (when (featurep 'org-superstar)
                  (setq-local org-superstar-headline-bullets-list '("🙘" "🙙" "🙚" "🙛")
                              org-superstar-remove-leading-stars t)
                  (org-superstar-restart))
                (setq
                 +zen--original-org-indent-mode-p org-indent-mode
                 +zen--original-org-pretty-table-mode-p (bound-and-true-p org-pretty-table-mode))
                (org-indent-mode -1)
                (org-pretty-table-mode 1))))
  (add-hook 'writeroom-mode-disable-hook
            (defun +zen-nonprose-org-h ()
              "Reverse the effect of `+zen-prose-org'."
              (when (eq major-mode 'org-mode)
                (when (featurep 'org-superstar)
                  (org-superstar-restart))
                (when +zen--original-org-indent-mode-p (org-indent-mode 1))
                ;; (unless +zen--original-org-pretty-table-mode-p (org-pretty-table-mode -1))
                ))))
#+end_src

* Extra Packages
Additional packages that don't fit into one of the existing Doom modules.
** Auto Activating Snippets
Don't require =TAB= to activate a snippet.

#+begin_src emacs-lisp :tangle packages.el
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets")
  :pin "1699bec4d244a1f62af29fe4eb8b79b6d2fccf7d")
#+end_src

** ETrace
Make ~Emacs Lisp Profiler~ into a more useful output.

#+begin_src emacs-lisp :tangle packages.el
(package! etrace :recipe (:host github :repo "aspiers/etrace"))
#+end_src

#+begin_src emacs-lisp
(use-package! etrace
  :after elp)
#+end_src

** Frame
Let the windows breath a little bit.

#+begin_src emacs-lisp
(use-package frame
  :config
  (setq-default default-frame-alist
                (append (list
                '(internal-border-width . 24)
                '(left-fringe    . 0)
                '(right-fringe   . 0)
                '(tool-bar-lines . 0)
                '(menu-bar-lines . 0)
                ;; '(line-spacing . 0.24)
                '(vertical-scroll-bars . nil))))
  (setq-default window-resize-pixelwise t)
  (setq-default frame-resize-pixelwise t))
#+end_src
** Info Colors
Make manual pages look nicer with colors.

#+begin_src emacs-lisp :tangle packages.el
(package! info-colors :pin "47ee73cc19b1049eef32c9f3e264ea7ef2aaf8a5")
#+end_src

Hook it into =Info=.

#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

** Graphviz
Visualize ~.dot~ graphs.

#+begin_src emacs-lisp :tangle packages.el
(package! graphviz-dot-mode :pin "3642a0a5f41a80c8ecef7c6143d514200b80e194")
#+end_src

#+begin_src emacs-lisp
(use-package! graphviz-dot-mode
  :commands graphviz-dot-mode
  :mode ("\\.dot\\'" "\\.gz\\'")
  :init
  (after! org
    (setcdr (assoc "dot" org-src-lang-modes)
            'graphviz-dot)))

(use-package! company-graphviz-dot
  :after graphviz-dot-mode)
#+end_src

** Prettier Page Breaks
Make page breaks look nice and sexy.

#+begin_src emacs-lisp :tangle packages.el
(package! page-break-lines :recipe (:host github :repo "purcell/page-break-lines"))
#+end_src

#+begin_src emacs-lisp
(use-package! page-break-lines
  :commands page-break-lines-mode
  :init
  (autoload 'turn-on-page-break-lines-mode "page-break-lines")
  :config
  (setq page-break-lines-max-width fill-column)
  (map! :prefix "g"
        :desc "Prev page break" :nv "[" #'backward-page
        :desc "Next page break" :nv "]" #'forward-page))
#+end_src

** Rotate Windows
The =rotate= package just adds the ability to rotate window layouts.

#+begin_src emacs-lisp :tangle packages.el
(package! rotate :pin "4e9ac3ff800880bd9b705794ef0f7c99d72900a6")
#+end_src

** String Inflection
For easy cycling of symbol cases.

#+begin_src emacs-lisp :tangle packages.el
(package! string-inflection :pin "fd7926ac17293e9124b31f706a4e8f38f6a9b855")
#+end_src

#+begin_src emacs-lisp
(use-package! string-inflection
  :commands (string-inflection-all-cycle
             string-inflection-toggle
             string-inflection-camelcase
             string-inflection-lower-camelcase
             string-inflection-kebab-case
             string-inflection-underscore
             string-inflection-capital-underscore
             string-inflection-upcase)
  :init
  (map! :leader :prefix ("c~" . "naming convention")
        :desc "cycle" "~" #'string-inflection-all-cycle
        :desc "toggle" "t" #'string-inflection-toggle
        :desc "CamelCase" "c" #'string-inflection-camelcase
        :desc "downCase" "d" #'string-inflection-lower-camelcase
        :desc "kebab-case" "k" #'string-inflection-kebab-case
        :desc "under_score" "_" #'string-inflection-underscore
        :desc "Upper_Score" "u" #'string-inflection-capital-underscore
        :desc "UP_CASE" "U" #'string-inflection-upcase)
  (after! evil
    (evil-define-operator evil-operator-string-inflection (beg end _type)
      "Define a new evil operator that cycles symbol casing."
      :move-point nil
      (interactive "<R>")
      (string-inflection-all-cycle)
      (setq evil-repeat-info '([?g ?~])))
    (define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection)))
#+end_src

